<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turbo Orange's Space</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <img src="turboorange.jpeg" alt="An orange sitting on the palmrest of a keyboard. The keyboard is blank. The image is all purple." class="banner">
        <pre class="ascii-art" style="color: purple; font-weight: bold;">
    ███        ▄█   ▄█▄  ▄█     ▄███████▄ 
▀█████████▄   ███ ▄███▀ ███    ███    ███ 
   ▀███▀▀██   ███▐██▀   ███▌   ███    ███ 
    ███   ▀  ▄█████▀    ███▌   ███    ███ 
    ███     ▀▀█████▄    ███▌ ▀█████████▀  
    ███       ███▐██▄   ███    ███        
    ███       ███ ▀███▄ ███    ███        
   ▄████▀     ███   ▀█▀ █▀    ▄████▀      
              ▀                           
        </pre>
    </header>
    <nav>
        <ul>
            <li><a href="/index.html">Home</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="/contact.html">Contact</a></li>
            <li><a href="/portfolio.html">Portfolio</a></li>
            <li><a href="/pong.html">pong</a></li>
        </ul>
    </nav>
    <main>
        <h1>Professional projects</h1>
        <article>
            <h2>edge and edge2</h2>
            <p>
                When I started at GSI, I was tasked with creating the tests for the first edge controller; the second revision wasn't available yet.
                I'm referring to test automation with hardware-in-the-loop. When I started, there was barely a test system in place.
                We were three in the team plus a manager, and together we made the decisions about how the testing would work.
                While the manager did much of the work, we contributed significantly to the structure.
                The final structure made the code so flexible that when the Edge2 revision was released, we ported all the tests quickly despite its drastic API changes.
                Those tests required creating internal REST APIs used to send pulses, serial messages, and other signals to the edge.

                I also ported all the tests from bamboo to github actions during a tech transition.

                The setup was also replicated to create tests for other products.

                tech: python, django, pytest, C++, github, github action, github local runner, bamboo, bitbucket, websocket, AWS

                <li><a href="https://www.automatedproduction.com/en_US/remote-management/edge2.html">Check it out!</a></li>
            </p>
        </article>
        <article>
            <h2>legacy connect</h2>
            <p>
                During a hackaton I made the code for the prototype what will be called later legacy connect.
                It's a card that bridges the serial port of old controlers to the cloud. This is a modernisation of older systems still sold and in function.

                I also created simulators and tests to make sure the final version actually works correctly.

                tech: python, typescript, MQTT, websocket, playwrite
                
                <li><a href="https://www.automatedproduction.com/content/dam/public/grain-and-protein/shared/manuals/ap-cumberland/english/climate-control/controls/892-00101_QSG_LCRXTX_LCRS485_EN_FR_REV04.pdf">Check it out!</a></li>
            </p>
        </article>
        <article>
            <h2>customer portal and customer API</h2>
            <p>
                I worked on an API that let customers get information on their controllers and a portal to manage the permissions and obtain API keys for the API.
                I did the testing and worked mostly on the backends. I made some frontend enhancements using my UX knowledge, mostly to give impaired people a better experience.

                tech: typescript, javascript, playwrite, react, express, MQTT, AWS
            </p>
        </article>
        <article>
            <h2>AI doc</h2>
            <p>
                I worked on a local internal AI chatbot tool to search scattered documentation. The idea is it would give the information and point out where it is.
                It's an idea to speed up product development.
            </p>
        </article>
        <h1>Personal projects</h1>
        <article>
            <h2>Readcode</h2>
            <p>
                This was my univercity final project. We worked in team to create a website that is inspired by leetcode but that works in reverse.
                We use the chatGPT AI to generate a random small code that is intentionally hard to read and the user has to explain with words what's going on.
                We then use the LLM again to score the answer.
                It works with any language that open AI have been traned on.

                It uses javascript, react, express openAI
                <li><a href="https://github.com/turboOrange/readcode">Check it out!</a></li>
                I updated it recently to get familiar with snyk.
            </p>
        </article>
            <h2>Spinach</h2>
            <p>
                I learned the basics of quantum computing and realized I'm not into any of the existing quantum languages. I just find that they don’t offer enough features to make developers’ lives easier—so I’m making my own.
                What this language introduces is the ability to name everything, the concept of pipelines, and, in the future, support for code reusability. It uses Pytket as a backend and will eventually be able to simulate, work in a jupyter notbook and compile into all the other major quantum languages.
                At the moment, it compiles into QASM.
                
                It uses Python with lark
                <li><a href="https://github.com/spinachlang/spinachlang">Check it out!</a></li>
            </p>
        </article>
        </article>
            <h2>Out of grave</h2>
            <p>
                This is the first language I made as a final project for my language creation course at UQAM. It's still a bit buggy but I leanred a lot doing it. It's the combination of two languages to create a small text based videogame faster then if we would do it with a general language.
                
                It uses Java with sablecc
                <li><a href="https://github.com/turboOrange/oog">Check it out!</a></li>
            </p>
        </article>

        </article>
            <h2>The password in yellow</h2>
            <p>
                This is my newest project. The idea is to create the exact same password manage in different languages to be able to compare them.
                I have a repo that details how those should work and I create a repo by langugages. At the moment, the python version is in construction.
                I want to write it in python, elixir and go.
                <li><a href="https://github.com/turboOrange/tpiy">Check it out! (documentation)</a></li>
                <li><a href="https://github.com/turboOrange/tpiy-titanoboa">Check it out! (Python version)</a></li>
            </p>
        </article>
    </main>
</body>
</html>